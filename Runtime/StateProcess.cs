// Autogenerated with StateSmith 0.19.0-alpha-1+5931a3a68e50c80e83349118a90569bf08270686.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#nullable enable

using System;

// Generated state machine
namespace AV.EssentialState.Runtime
{
    [Serializable]
    public partial struct StateProcess : IEssentialState<StateProcess.EventId>
    {
        public enum EventId
        {
            ADMIT = 0,
            DISPATCH = 1,
            EVENT_OCCURS = 2,
            EVENT_WAIT = 3,
            RELEASE = 4
        }

        public const int EventIdCount = 5;

        public enum StateId
        {
            ROOT = 0,
            BLOCKED = 1,
            EXIT = 2,
            NEW = 3,
            READY = 4,
            RUNNING = 5
        }

        public const int StateIdCount = 6;

        // Used internally by state machine. Feel free to inspect, but don't modify.
        public StateId stateId;

        // Starts the state machine. Must be called before dispatching events. Not thread safe.
        public void Start()
        {
            ROOT_enter();
            // ROOT behavior
            // uml: TransitionTo(ROOT.<InitialState>)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
                // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

                // ROOT.<InitialState> behavior
                // uml: TransitionTo(NEW)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                    // Step 2: Transition action: ``.

                    // Step 3: Enter/move towards transition target `NEW`.
                    NEW_enter();

                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                } // end of behavior for ROOT.<InitialState>
            } // end of behavior for ROOT
        }

        // Dispatches an event to the state machine. Not thread safe.
        // Note! This function assumes that the `eventId` parameter is valid.
        public void DispatchEvent(EventId eventId)
        {
            switch (stateId)
            {
                // STATE: StateProcess
                case StateId.ROOT:
                    // No events handled by this state (or its ancestors).
                    break;

                // STATE: BLOCKED
                case StateId.BLOCKED:
                    switch (eventId)
                    {
                        case EventId.EVENT_OCCURS: BLOCKED_event_occurs(); break;
                    }

                    break;

                // STATE: EXIT
                case StateId.EXIT:
                    // No events handled by this state (or its ancestors).
                    break;

                // STATE: NEW
                case StateId.NEW:
                    switch (eventId)
                    {
                        case EventId.ADMIT: NEW_admit(); break;
                    }

                    break;

                // STATE: READY
                case StateId.READY:
                    switch (eventId)
                    {
                        case EventId.DISPATCH: READY_dispatch(); break;
                    }

                    break;

                // STATE: RUNNING
                case StateId.RUNNING:
                    switch (eventId)
                    {
                        case EventId.EVENT_WAIT: RUNNING_event_wait(); break;
                        case EventId.RELEASE: RUNNING_release(); break;
                    }

                    break;
            }
        }

        // This function is used when StateSmith doesn't know what the active leaf state is at
        // compile time due to sub states or when multiple states need to be exited.
        private void ExitUpToStateHandler(StateId desiredState)
        {
            while (stateId != desiredState)
                switch (stateId)
                {
                    case StateId.BLOCKED: BLOCKED_exit(); break;

                    case StateId.EXIT: EXIT_exit(); break;

                    case StateId.NEW: NEW_exit(); break;

                    case StateId.READY: READY_exit(); break;

                    case StateId.RUNNING: RUNNING_exit(); break;

                    default: return; // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
                }
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ROOT
        ////////////////////////////////////////////////////////////////////////////////

        private void ROOT_enter()
        {
            stateId = StateId.ROOT;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state BLOCKED
        ////////////////////////////////////////////////////////////////////////////////

        private void BLOCKED_enter()
        {
            stateId = StateId.BLOCKED;
        }

        private void BLOCKED_exit()
        {
            stateId = StateId.ROOT;
        }

        private void BLOCKED_event_occurs()
        {
            // BLOCKED behavior
            // uml: EVENT_OCCURS TransitionTo(READY)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                BLOCKED_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `READY`.
                READY_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            } // end of behavior for BLOCKED

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state EXIT
        ////////////////////////////////////////////////////////////////////////////////

        private void EXIT_enter()
        {
            stateId = StateId.EXIT;
        }

        private void EXIT_exit()
        {
            stateId = StateId.ROOT;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state NEW
        ////////////////////////////////////////////////////////////////////////////////

        private void NEW_enter()
        {
            stateId = StateId.NEW;

            // NEW behavior
            // uml: enter / { Setup(); }
            {
                Setup();
            } // end of behavior for NEW
        }

        private void NEW_exit()
        {
            stateId = StateId.ROOT;
        }

        private void NEW_admit()
        {
            // NEW behavior
            // uml: ADMIT TransitionTo(READY)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                NEW_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `READY`.
                READY_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            } // end of behavior for NEW

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state READY
        ////////////////////////////////////////////////////////////////////////////////

        private void READY_enter()
        {
            stateId = StateId.READY;
        }

        private void READY_exit()
        {
            stateId = StateId.ROOT;
        }

        private void READY_dispatch()
        {
            // READY behavior
            // uml: DISPATCH TransitionTo(RUNNING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                READY_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `RUNNING`.
                RUNNING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            } // end of behavior for READY

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state RUNNING
        ////////////////////////////////////////////////////////////////////////////////

        private void RUNNING_enter()
        {
            stateId = StateId.RUNNING;
        }

        private void RUNNING_exit()
        {
            stateId = StateId.ROOT;
        }

        private void RUNNING_event_wait()
        {
            // RUNNING behavior
            // uml: EVENT_WAIT TransitionTo(BLOCKED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                RUNNING_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `BLOCKED`.
                BLOCKED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        private void RUNNING_release()
        {
            // RUNNING behavior
            // uml: RELEASE TransitionTo(EXIT)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                RUNNING_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `EXIT`.
                EXIT_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        // Thread safe.
        public static string StateIdToString(StateId id)
        {
            switch (id)
            {
                case StateId.ROOT: return "ROOT";
                case StateId.BLOCKED: return "BLOCKED";
                case StateId.EXIT: return "EXIT";
                case StateId.NEW: return "NEW";
                case StateId.READY: return "READY";
                case StateId.RUNNING: return "RUNNING";
                default: return "?";
            }
        }

        // Thread safe.
        public static string EventIdToString(EventId id)
        {
            switch (id)
            {
                case EventId.ADMIT: return "ADMIT";
                case EventId.DISPATCH: return "DISPATCH";
                case EventId.EVENT_OCCURS: return "EVENT_OCCURS";
                case EventId.EVENT_WAIT: return "EVENT_WAIT";
                case EventId.RELEASE: return "RELEASE";
                default: return "?";
            }
        }
    }
}